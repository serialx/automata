Automata Project 2-1: Report (결과보고서)
=========================================

Name: 홍성진 (20060735, serialx@serialx.net)


DFA Membership Check Complexity
-------------------------------
Input length N, Transition function size T (~= Output function size) 에 대하여 Worst-case Complexity는 O(T+N) 입니다. Transition Function에 대하여 Hash Table을 사용하여 O(N)에 바운드 시켜 최적화 하였습니다.

eNFA to DFA Conversion Complexity
---------------------------------
State Enumeration을 하고 epsilon closure를 함으로 최악의 경우에는 State 수 S와 Transition function size T 대하여 O((2^S)*T)입니다. (이게 정확한 분석인지는 모르겠습니다.)

Minimal State DFA Computation Complexity
----------------------------------------
State 수 S에 대하여 O(S^3) 입니다. Loop를 이중으로 돌며 안에서 실행되는 Recursive 함수는 Memoization을 통하여 Table Filling을 하기 때문에 최대 호출 횟수는 S에 바운드 됩니다. 따라서 최대 O(S^3)

Input Method
------------
이전 프로젝트와 마찬가지로 input_nfa.txt를 eval함수를 사용하여 로드하도록 하였습니다. Epsilon은 파이썬에 동등한 빈 문자열 ''로 대응하였습니다.

Exmaples
--------
H.W. #5 3번 문제를 기본으로 입력해 놓았습니다.

### NFA Input
```
$ cat input_nfa.txt
(
# States
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13},
# Alphabet
{'0', '1', ''},
# Transition Function
{
    ((1, ''), 2),
    ((1, ''), 8),
    ((2, ''), 3),
    ((2, ''), 4),
    ((3, '0'), 5),
    ((4, '1'), 6),
    ((5, ''), 7),
    ((6, ''), 7),
    ((7, ''), 2),
    ((7, ''), 8),
    ((8, '0'), 9),
    ((9, '1'), 10),
    ((10, '1'), 11),
    ((11, '0'), 12),
    ((12, '1'), 13),
},
# Start State
1,
# Accept States
{13},
)
```

### Test Output of '01101'
```
$ python nfa.py
= NFA =
NFA(states=set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]), 
    alphabet=set(['', '1', '0']), 
    transition_function=set([((8, '0'), 9), ((11, '0'), 12), ((7, ''), 8), ((2, ''), 3), ((10, '1'), 11), ((1, ''), 2), ((1, ''), 8), ((4, '1'), 6), ((6, ''), 7), ((5, ''), 7), ((3, '0'), 5), ((7, ''), 2), ((12, '1'), 13), ((2, ''), 4), ((9, '1'), 10)]), 
    start_state=1, 
    accept_state=set([13]))
(+) Converting to DFA...

= DFA =
DFA(states=set([frozenset([8, 1, 2, 3, 4]), frozenset([2, 3, 4, 5, 7, 8, 9]), frozenset([2, 3, 4, 5, 7, 8, 9, 12]), frozenset([2, 3, 4, 6, 7, 8, 10, 13]), frozenset([2, 3, 4, 6, 7, 8]), frozenset([2, 3, 4, 6, 7, 8, 11]), frozenset([2, 3, 4, 6, 7, 8, 10])]), 
    alphabet=set(['1', '0']), 
    transition_function=set([((frozenset([2, 3, 4, 5, 7, 8, 9]), '1'), frozenset([2, 3, 4, 6, 7, 8, 10])), ((frozenset([2, 3, 4, 6, 7, 8]), '1'), frozenset([2, 3, 4, 6, 7, 8])), ((frozenset([2, 3, 4, 6, 7, 8, 11]), '0'), frozenset([2, 3, 4, 5, 7, 8, 9, 12])), ((frozenset([8, 1, 2, 3, 4]), '1'), frozenset([2, 3, 4, 6, 7, 8])), ((frozenset([2, 3, 4, 6, 7, 8]), '0'), frozenset([2, 3, 4, 5, 7, 8, 9])), ((frozenset([2, 3, 4, 6, 7, 8, 10, 13]), '1'), frozenset([2, 3, 4, 6, 7, 8, 11])), ((frozenset([2, 3, 4, 5, 7, 8, 9]), '0'), frozenset([2, 3, 4, 5, 7, 8, 9])), ((frozenset([2, 3, 4, 5, 7, 8, 9, 12]), '0'), frozenset([2, 3, 4, 5, 7, 8, 9])), ((frozenset([2, 3, 4, 5, 7, 8, 9, 12]), '1'), frozenset([2, 3, 4, 6, 7, 8, 10, 13])), ((frozenset([2, 3, 4, 6, 7, 8, 11]), '1'), frozenset([2, 3, 4, 6, 7, 8])), ((frozenset([8, 1, 2, 3, 4]), '0'), frozenset([2, 3, 4, 5, 7, 8, 9])), ((frozenset([2, 3, 4, 6, 7, 8, 10]), '0'), frozenset([2, 3, 4, 5, 7, 8, 9])), ((frozenset([2, 3, 4, 6, 7, 8, 10, 13]), '0'), frozenset([2, 3, 4, 5, 7, 8, 9])), ((frozenset([2, 3, 4, 6, 7, 8, 10]), '1'), frozenset([2, 3, 4, 6, 7, 8, 11]))]), 
    start_state=frozenset([8, 1, 2, 3, 4]), 
    accept_state=set([frozenset([2, 3, 4, 6, 7, 8, 10, 13])]))
(+) Renaming states...

= Renamed DFA =
DFA(states=set([1, 2, 3, 4, 5, 6, 7]), 
    alphabet=set(['1', '0']), 
    transition_function=set([((4, '0'), 2), ((1, '1'), 5), ((1, '0'), 2), ((5, '0'), 2), ((2, '0'), 2), ((6, '0'), 3), ((7, '0'), 2), ((3, '1'), 4), ((4, '1'), 6), ((7, '1'), 6), ((2, '1'), 7), ((3, '0'), 2), ((6, '1'), 5), ((5, '1'), 5)]), 
    start_state=1, 
    accept_state=set([4]))
(+) Computing mDFA...
reachable_states = set([1, 2, 3, 4, 5, 6, 7])
equivalent_state_pairs = set([frozenset([5, 7]), frozenset([5, 6]), frozenset([1, 5]), frozenset([1, 7]), frozenset([1, 6]), frozenset([1, 2]), frozenset([2, 5])])

= mDFA =
DFA(states=set([1, 2, 3, 4, 5, 6]), 
    alphabet=set(['1', '0']), 
    transition_function=set([((2, '1'), 3), ((5, '1'), 6), ((1, '0'), 5), ((3, '1'), 4), ((4, '0'), 5), ((6, '0'), 5), ((3, '0'), 1), ((2, '0'), 5), ((6, '1'), 3), ((4, '1'), 4), ((5, '0'), 5), ((1, '1'), 2)]), 
    start_state=4, 
    accept_state=set([2]))

= Output (As per homework specs) =
state = {1, 2, 3, 4, 5, 6}
final_state = {2}
start_state = 4
(2, 3, 1)
(5, 6, 1)
(1, 5, 0)
(3, 4, 1)
(4, 5, 0)
(6, 5, 0)
(3, 1, 0)
(2, 5, 0)
(6, 3, 1)
(4, 4, 1)
(5, 5, 0)
(1, 2, 1)

= Test =
01101
(4, 0) --> set([5])
(5, 1) --> set([6])
(6, 1) --> set([3])
(3, 0) --> set([1])
(1, 1) --> set([2])
"01101" in DFA = True
```

Retrospect
----------
구현하면서 DFA의 성능 최적화 외에는 DFA코드를 그대로 사용하였으며 변환된 DFA가 가독성이 좋지 않아 숫자로 대응시켜 rename하는 기능도 추가 구현하였습니다.

NFA(...).to_dfa().rename().minimize() 등의 방법으로 eNFA를 mDFA로 손쉽게 변환 가능하도록 하였습니다.

아직 DFA Minimization 알고리즘에 대하여 완벽하게 동작할거라는 확인이 없는데 모든 state pair에 대하여  Memoizing을 하는 internal recursive function을 호출하는데 호출 순서에 따라 state간의 종속성으로 제대로 distinguish가 안되는 경우가 있을 수 있다는 두려움이 있습니다. 엄밀한 증명이 필요할 것 같은데 공부가 더 필요할 것으로 보입니다.

조교님들 수고 많으십니다. 감사합니다.
